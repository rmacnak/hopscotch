(* An IDE for Newspeak on the web.
    Copyright 2016-2017 Google Inc.
*)
(* :exemplar: ide browsing *)
class Browsing usingPlatform: p ide: webIde = (
|
	private StringBuilder = p kernel StringBuilder.
	private Subject = p hopscotch core Subject.
	private Presenter = p hopscotch core Presenter.
	private TextEditorFragment = p hopscotch fragments TextEditorFragment.
	private Color = p graphics Color.
	private Gradient = p hopscotch Gradient.
	private WeakArray = p kernel WeakArray.
	private List = p collections List.
	private Map = p collections Map.
	private Set = p collections Set.
	private ClassMirror = p mirrors ClassMirror.
	private ObjectMirror = p mirrors ObjectMirror.
	private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	private JSObject = [p js global at: 'Object'] on: Exception do: [:e | nil].
	private DateTime = p time DateTime.

	private random = p random Random new.
	private cachedPlatform = p.
	private ide = webIde.
	private detailAreaRatio = 3 asFloat.
	private captionColor = Color h: 41 s: 0.20 v: 0.80.
	private cssConverter = cssConversionTable.
|
) (
(* The subject is a collection of MethodSubjects that can come from diverse sources (in the sense that they do not have to belong to the same class). The presenter displays them as a column of expandable method presenters and takes care of reasonably handling the various creation and deletion requests coming from them.  I group my methods by their containing package.

Slots
	title	<String>	The title to use for the presenter
	methodPresenters <List[ExpandableMethodPresenter]> Because the method presenters are grouped by package, if we need to expand or collapse those presenters, we only want to expand or collapse the method presenters.  The group heading is not expandable (or collapsable). *)
public class AssortedMethodsPresenter onSubject: s = DefinitionListPresenter onSubject: s (
|
	public title ::= 'Assorted Methods'.
	methodPresenters ::= List new.
|) (
contentPresenters = (
	^subject methodSubjects collect: [:each | each presenter]
)
respondToCollapse: presenters = (
	presenters do: [:each | each collapse].
)
respondToExpand: presenters = (
	presenters do: [:each | each expand].
)
) : (
)
class BasicView onSubject: s = ProgrammingPresenter onSubject: s (
) (
definition = (
	^column:
		(subject slots collect:
			[:slot <SlotSubject> | slot presenter])
)
public title = (
	^'Basic'
)
) : (
)
public class BitOfWisdom text: s <String> actionLabel: l <String> actionBlock: b <[]> image: i = (|
	public text <String> = s.
	public image = i.
	public actionLabel <String> = l.
	public actionBlock <[]> = b.
|) (
) : (
public text: s <String> ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: nil
)
public text: s <String> actionLabel: l <String> actionBlock: b <[]> ^ <BitOfWisdom> = (
	^self
		text: s
		actionLabel: l
		actionBlock: b
		image: nil
)
public text: s image: i ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: i
)
)
class ClassActionsPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
definition = (
	subject isApplicationConfiguration ifTrue:
		[^row: {
			link: '[run]' action: [respondToRunApp: false].
			link: '[debug]' action: [respondToRunApp: true].
		}].
	subject isTestConfiguration ifTrue:
		[^link: '[run tests]' action: [respondToRunTests]].
	^nothing
)
respondToRunApp: paused = (
	(* bogus: The subject might not be in the root namespace. *)
	| appConfig manifest platform args thread |
	appConfig:: ide namespacing Root at: subject name.
	manifest:: ide namespacing manifest.
	platform:: cachedPlatform.
	args:: {}.
	thread:: platform mirrors ActivationMirror invokeSuspended:
		[(appConfig packageUsing: manifest) main: platform args: args].
	paused ifFalse: [thread resume].
	thread isFulfilled ifFalse:
		[enterSubject:: ide debugging ThreadSubject onModel: thread].
)
respondToRunTests = (
	(* bogus: The subject might not be in the root namespace. *)
	enterSubject:: ide minitestUI TestingInProgressSubject
		onConfiguration: (ide namespacing Root at: subject name)
		platform: cachedPlatform
		minitest: ide minitest
)
) : (
)
class ClassHeaderPresenter onSubject: s = MemberPresenter onSubject: s (
) (
acceptResponse ^<[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <ClassDeclarationBuilder> = subject classDeclaration asBuilder. |
		b header source: ed textBeingAccepted.
		b install.
		colorizeSource: ed textBeingAccepted withEditor: ed.
		ed leaveEditState.
		]
)
colorizeSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeHeader: s fromMixin: subject classDeclaration instanceSide via: (colorizingBlockFor: cm)
)
) : (
)
public class ClassHeaderSubject onModel: m <ClassHeaderMirror> = Subject onModel: m (
) (
public accessModifier = (
	^model declaration accessModifier
)
public classDeclaration = (
	^model declaration
)
public commentSummary ^<String> = (
	^summarizeCommentFromMetadata: model metadata
)
public createPresenter = (
	^ClassHeaderPresenter onSubject: self
)
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
public enclosingClasses ^<List[MixinMirror]> = (
	| classes currentClass |
	classes:: List new.
	currentClass:: model declaration.
	[currentClass isNil]
		whileFalse:
			[classes add: currentClass instanceSide.
			 currentClass:: currentClass enclosingClass].
	^classes
)
public messages = (
	| result sent |
	result:: List new.
	result add: model name.
	result add: model primaryFactorySelector.
	model declaration instanceSide slots do:
		[:slot |
		 result add: slot name.
		 slot isMutable ifTrue: [result add: slot name, ':']].
	sent:: Array withAll: model selectors.
	sent sort: [:a :b | lexicallyLessOrEqual: a than: b].
	result addAll: sent.
	result addAll: ((model metadata collect: [:ea | ea tag]) reject: [:ea | nil = ea]).
	^result
)
public name = (
	^model primaryFactorySelector
)
public source = (
	^model source
)
) : (
)
class ClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
classActionsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Mirror'. [inspectObject: subject classMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
		{'Inspect Instances'. [respondToInspectInstances]}.
		{'Delete'. [respondToDelete]}.
	}
)
classNameAndContainmentDefinition ^<Fragment> = (
	| parts <List[Fragment]> |
	parts:: List new.
	subject enclosingClassSubjects
		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]
		separatedBy: [parts add: (label: ' in ')].
	^row: {
		image: ide images classIcon.
		blank: 5.
		row: parts.
		filler.
		ClassActionsPresenter onSubject: subject.
		smallBlank.
		referencesMenu.
		smallBlank.
		dropDownMenu: [classActionsMenu].
		largeBlank.
		homeButton.
		smallBlank.
		refreshButton.
	}
)
classes: classes labelled: name = (
	| parts = List new. |
	parts add: (label: name).
	classes do:
		[:each |
		 parts add: smallBlank.
		 parts add: (link: each name action: [enterSubject: each])].
	classes isEmpty ifTrue:
		 [parts add: smallBlank.
		  parts add: (label: '(none)')].
	^flow: parts
)
definition ^<Fragment> = (
	^column: {
		headingDefinition.
		minorClassHeadingBlock: (label: 'Header').
		subject classHeaderSubject presenter.
		sectionLabelled: 'Classes' presenting: subject nestedClassesSubject.
		sectionLabelled: 'Transient Slots' presenting: subject transientSlotsSubject.
		sectionLabelled: 'Methods' presenting: subject methodsSubject.
		sectionLabelled: 'Class Methods' presenting: subject classMethodsSubject.
	}
)
headingDefinition ^<Fragment> = (
	^(padded: (column: {
		classNameAndContainmentDefinition.
		smallBlank.
		classes: subject superclassSubjects labelled: 'Superclasses:'.
		classes: subject subclassSubjects labelled: 'Subclasses:'.
	}) with: {10. 5. 10. 5.}) color: (Color h: 41 s: 0.20 v: 0.80).
)
minorClassHeadingBlock: body = (
	^(padded: body with: {10. 5. 10. 5.})
		color: minorClassHeadingColor
)
minorClassHeadingColor = (
	^Gradient
		from: (Color h: 41 s: 0.20 v: 0.90)
		to: (Color h: 41 s: 0.20 v: 0.80)
)
referencesMenu = (
	^referencesMenu:
		[menuWithLabelsAndActions:
			(subject messages collect:
				[:selector | { selector. [navigateToSelector: selector] }])]
)
respondToDelete = (
	| enclosing = subject enclosingClassSubject. |
	subject deleteClass.
	enterSubject: enclosing.
)
respondToInspectInstances = (
	| instances = List new. |
	subject classMirror instanceSide applications do:
		[:application | application instances reflectee do:
			[:instance | instances add: instance]].
	inspectObject: instances.
)
sectionLabelled: title <String> presenting: groupSubject <MirrorGroupSubject> = (
	| groupPresenter = groupSubject presenter. |
	^column: {
		minorClassHeadingBlock: (
			row: {
				label: title.
				largeBlank.
				addButtonWithAction: [groupPresenter addNewItemTemplate].
				filler.
				expandButtonWithAction: [groupPresenter expandAll].
				blank: 3.
				collapseButtonWithAction: [groupPresenter collapseAll].
				}
			).
		groupPresenter.
		}
)
) : (
)
public class ClassSubject onModel: m <ClassDeclarationMirror> = Subject onModel: m (
) (
public accessModifier = (
	^classMirror accessModifier
)
public classHeaderSource = (
	^classMirror header source
)
public classHeaderSubject = (
	^ClassHeaderSubject onModel: classMirror header
)
public classMethodsSubject ^ <MethodGroupSubject> = (
	^MethodGroupSubject onModel: classMirror classSide methods within: classMirror classSide
)
public classMirror ^ <ClassDeclarationMirror> = (
	^model
)
public commentSummary ^<String> = (
	^summarizeCommentFromMetadata: model header metadata
)
public createPresenter = (
	^ClassPresenter onSubject: self
)
public deleteClass = (
	| builder |
	nil = model enclosingClass ifTrue: [halt].
	builder:: model enclosingClass asBuilder.
	builder instanceSide nestedClasses removeMirrorNamed: model name.
	builder install.
)
public enclosingClassSubject = (
	^ClassSubject onModel: model enclosingClass
)
public enclosingClassSubjects = (
	| them = List new. c |
	c:: model.
	[c isNil] whileFalse: [them add: (ClassSubject onModel: c). c:: c enclosingClass].
	^them
)
public isApplicationConfiguration = (
	isTopLevel ifFalse: [^false].
	model header primaryFactorySelector = #packageUsing: ifTrue: [^true].
	^model classSide methods anySatisfy: [:method | method name = #packageUsing:].
)
public isTestConfiguration = (
	isTopLevel ifFalse: [^false].
	model header primaryFactorySelector = #packageTestsUsing: ifTrue: [^true].
	^model classSide methods anySatisfy: [:method | method name = #packageTestsUsing:].
)
public isTopLevel = (
	^nil = model enclosingClass
)
public messages = (
	| header result sent |
	header:: classMirror header.
	result:: List new.
	result add: header name.
	result add: header primaryFactorySelector.
	header declaration instanceSide slots do:
		[:slot |
		 result add: slot name.
		 slot isMutable ifTrue: [result add: slot name, ':']].
	sent:: Array withAll: header selectors.
	sent sort: [:a :b | lexicallyLessOrEqual: a than: b].
	result addAll: sent.
	result addAll: ((header metadata collect: [:ea | ea tag]) reject: [:ea | nil = ea]).
	^result
)
public methodsSubject ^ <MethodGroupSubject> = (
	^MethodGroupSubject onModel: classMirror instanceSide methods within: classMirror instanceSide
)
public name = (
	^model name
)
public nestedClassesSubject ^ <NestedClassGroupSubject> = (
	^NestedClassGroupSubject onModel: classMirror instanceSide nestedClasses within: classMirror instanceSide
)
public primaryFactorySelector = (
	^model header primaryFactorySelector
)
public subclassSubjects = (
	| them ::= Set new. |
	classMirror instanceSide applications do:
		[:each | each subclasses do:
			[:each | them add: each mixin declaration]].
	them:: them asArray.
	them sort: [:a :b | lexicallyLessOrEqual: a name than: b name].
	^them collect: [:each | ClassSubject onModel: each]
)
public superclassSubjects = (
	| them ::= Set new. |
	classMirror instanceSide applications do:
		[:each | nil = each superclass ifFalse:
			[them add: each superclass mixin declaration]].
	them:: them asArray.
	them sort: [:a :b | lexicallyLessOrEqual: a name than: b name].
	^them collect: [:each | ClassSubject onModel: each]
)
public title = (
	^name
)
public transientSlotsSubject ^ <TransientSlotGroupSubject> = (
	^TransientSlotGroupSubject onModel: classMirror instanceSide transientSlots within: classMirror instanceSide
)
) : (
)
(* DefinitionListPresenter is an abstract superclass of presenters that displays helper ''transient'' presenters that visually appear to belong to the main list of subject presenters. One common example is a method list presenter which can at times include presenters for methods being added or residue presenters of removed methods. *)
public class DefinitionListPresenter onSubject: s = ProgrammingPresenter onSubject: s (
| 
prefixes <PresenterList> 
content <PresenterList> 
suffixes <PresenterList> 
|
) (
public collapseAll = (
	(* Collapse all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	(*majorUpdate: [*)
		content presenters do: [:each | each collapse]
		(*]*)
)
contentList ^ <PresenterList> = (
	^list: [contentPresenters]
)
contentPresenters ^ <List[Presenter]> = (
	^List new
)
definition ^ <Fragment> = (
	prefixes:: list.
	content:: contentList.
	suffixes:: list.
	^column: {
		prefixes.
		content.
		suffixes.
	}
)
public expandAll = (
	(* Expand all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	(*majorUpdate: [*)
		content presenters do: [:each | each expand]
		(*]*)
)
) : (
)
public class DefinitionTemplate
   caption: c <String>
   initialText: t <String | Text>
   colorizerBlock: cb <[:String :CodeMirrorFragment]>
   acceptResponse: onAccept <[DefinitionTemplate]>
   cancelResponse: onCancel <[DefinitionTemplate]>
 = ProgrammingPresenter onSubject: nil (|
	public caption = c.
	public initialText = t.
	public initiallyInEditState ::= true.
	public acceptResponse = onAccept.
	public cancelResponse = onCancel.
	public editor
	public colorizerBlock = cb.
|) (
definition ^ <Fragment> = (
	^(row: {
		mediumBlank.
		elastic:
			(column: {
				smallBlank.
				label: caption.
				editorDefinition.
				mediumBlank.
 			}).
		smallBlank.
		}) color: (Gradient from: (Color h: 100 s: 0.3 v: 0.9) to: (Color h: 100 s: 0.3 v: 0.8))
)
editorDefinition ^ <Fragment> = (
	editor:: (codeMirror: initialText)
	(*	acceptLabelText: 'save';
		cancelLabelText: 'cancel';*)
		acceptResponse: [acceptResponse value: self];
		changeResponse: [:cm <CodeMirrorFragment> :event <Event>  | colorizerBlock value: cm textBeingAccepted value: cm];
		cancelResponse: [cancelResponse value: self].
	initiallyInEditState ifTrue: [editor enterEditState].
	colorizerBlock value: initialText value: editor.
	^editor
)
public text = (
	^editor textBeingAccepted
)
) : (
)
class EntryPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
public collapse = (
	substance collapse
)
definition = (
	^collapsed: [collapsedDefinition] expanded: [expandedDefinition]
)
public expand = (
	substance expand
)
row1: row1 row2: row2 = (
	^row: {
		(row: row1) width: 0 elasticity: 1.
		(row: {mediumBlank}, row2) width: 0 elasticity: 2.
	}
)
) : (
)
public class EvaluationPresenter onSubject: s <ObjectSubject | ActivationSubject> = ProgrammingPresenter onSubject: s (
	|
	editor
	results
	|
) (
addDiscardIfNeeded = (
	results presenters isEmpty ifTrue:
		[results add: discardResultsDefinition].
)
clearResults = (
	results presenters: {}.
)
definition = (
	^column: {
		row: {
			editor:: editorDefinition
				width: 0 elasticity: 1.
			smallBlank.
			button: 'Evaluate' action: [respondToEvaluate: false].
			smallBlank.
			button: 'Debug' action: [respondToEvaluate: true].
		}.
		results:: list: {}.
	}
)
discardResultsDefinition = (
	^row: {
		filler.
		(link: 'discard results' action: [clearResults]) (* tinyFont *)
	}
)
editorDefinition ^ <CodeMirrorFragment> = (
	| initialSource cm <CodeMirrorFragment> |
	initialSource:: ''.
	cm:: (codeMirror: initialSource).
	cm changeResponse:
		[:editor <CodeMirrorFragment>  |
		| src <String> =  editor textBeingAccepted. |
		ide colorizer colorizeDoIt: src fromMixin: nil via: (colorizingBlockFor: editor)].
	cm enterResponse:
		[:editor <CodeMirrorFragment> |
		 respondToEvaluate: false].
	ide colorizer colorizeDoIt: initialSource fromMixin: nil via: (colorizingBlockFor: cm).
	^cm
)
evaluate: expression <String> suspended: suspended <Boolean> ^<Fragment> = (
	| thread <ThreadMirror> |

	[thread:: subject evaluate: expression suspended: suspended]
		on: Exception do: [:e | ^linkForCompileError: e].

	^EvaluationResultPresenter onSubject:
		(ide debugging ThreadSubject onModel: thread)
)
linkForCompileError: error <Exception> = (
	^column: {
		smallBlank.
		(link: error printString action:
			[inspectObjectMirror: (ObjectMirror reflecting: error)])
				color: (Color r: 1 g: 0 b: 0).
	}
)
respondToEvaluate: suspended <Boolean> = (
	| src = editor textBeingAccepted. |
	addDiscardIfNeeded.
	results addFirst: (evaluate: src suspended: suspended).
	ide colorizer colorizeDoIt: src fromMixin: nil via: (colorizingBlockFor: editor)
)
) : (
)
class EvaluationResultPresenter onSubject: s <ThreadSubject> = ProgrammingPresenter onSubject: s (
) (
definition = (
	^holder: [definitionX]
)
definitionX = (
	subject isFulfilled ifTrue:
		[^link: subject threadMirror result reflectee printString
		  action: [enterSubject:: ObjectSubject onModel: subject threadMirror result]].

	subject isBroken ifTrue:
		[^(link: subject threadMirror result reflectee printString
		   action: [enterSubject:: subject])
			color: (Color r: 1 g: 0 b: 0)].

	subject isSuspended ifTrue:
		[^(link: subject refreshActivationChain first title
		   action: [enterSubject:: subject])
			color: (Color r: 1 g: 0 b: 0)].

	^label: 'Unknown state'
)
) : (
)
class HomePresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
column1: definitions1 column2: definitions2 column3: definitions3 = (
	^row: {
		(column: definitions1) width: 0 elasticity: 1.
		(column: definitions2) width: 0 elasticity: 1.
		(column: definitions3) width: 0 elasticity: 1.
	}
)
definition = (
	^column: {
		majorHeadingBlock: (label: 'Navigation').
		mediumBlank.

		indentedBlock:
			(column1: {
				link: 'Namespace' action: [navigateToNamespace].
			}
			column2: {
				link: 'Workspaces' action: [navigateToWorkspaces].
			}
			column3: {
				link: 'Selectors' action: [navigateToSelectors].
				link: 'Metadata' action: [navigateToMetadata].
				link: 'No Senders' action: [navigateToNoSenders].
				link: 'No Implementors' action: [navigateToNoImplementors].
			}).
		mediumBlank.

(*		majorHeadingBlock: (label: 'Recently Visited' asText allBold).
		mediumBlank.
		indentedBlock:
			(holder: [recentStuffDefinition]).
		largeBlank.*)

		majorHeadingBlock: (label: 'Did you know?').
		mediumBlank.

		indentedBlock:
			(holder: [didYouKnow]).
	}
)
didYouKnow = (
	| wisdom |
	wisdom:: subject randomBitOfWisdom.
	nil = wisdom actionLabel ifFalse:
		[^textAndActionWisdom: wisdom].
	nil = wisdom image ifFalse:
		[^textAndImageWisdom: wisdom].
	^textDisplay: wisdom text
)
navigateToMetadata = (
	ide namespacing reindex.
	enterSubject:: ide namespacing AllMetadataSubject new.
)
navigateToNamespace = (
	enterSubject:: NamespaceSubject new.
)
navigateToNoImplementors = (
	ide namespacing reindex.
	enterSubject:: ide namespacing NoImplementorsSubject new.
)
navigateToNoSenders = (
	ide namespacing reindex.
	enterSubject:: ide namespacing NoSendersSubject new.
)
navigateToSelectors = (
	ide namespacing reindex.
	enterSubject:: ide namespacing AllSelectorsSubject new.
)
navigateToWorkspaces = (
	enterSubject:: ide theWorkspaceManager AllWorkspacesSubject new.
)
textAndActionWisdom: wisdom = (
	^column: {
		textDisplay: wisdom text.
		(link: wisdom actionLabel action: wisdom actionBlock) smallFont
	}
)
textAndImageWisdom: wisdom = (
	^row: {
		image: wisdom image.
		mediumBlank.
		elastic:
			(textDisplay: wisdom text).
	}
)
) : (
)
public class HomeSubject onModel: m = Subject onModel: m () (
public = anotherSubject <Subject> ^ <Boolean> = (
	(* As there is just one possible logical home of the system, all subjects representing it are considered equal. *)
	^anotherSubject isKindOfHomeSubject
)
bitsOfWisdom = (
	(* This defines the bits of wisdom displayed at the bottom of the Hopscotch home page. Each time a page opens a new element is selected at random. An element may evaluate to nil, which will select another element at random. *)
	^{
	[BitOfWisdom
		text: 'This is the "expand all" button which appears in headers of expandable item groups.'
		image: ide images expandImage].

	[BitOfWisdom
		text: 'This is the "collapse all" button which appears in headers of expandable item groups.'
		image: ide images collapseImage].

	[BitOfWisdom
		text: 'This is the "add" button which appears in headers of groups of items you can add to, such as methods of a class or classes of a package.'
		image: ide images addImage].

	[BitOfWisdom
		text: 'Expressions evaluated in debuggers and inspectors can access a workspace via the name _. This allows you to bypass modularity during development and access values you forgot to import, e.g. _ collections List.'].

	[BitOfWisdom
		text: 'This icon identifies Newspeak classes.'
		image: ide images classIcon].

	[BitOfWisdom
		text: 'This icon identifies namespaces.'
		image: ide images classPresenterIcon].

	[BitOfWisdom
		text: 'War is peace. Freedom is slavery. Ignorance is strength.'].
	}
)
public createPresenter = (
	^HomePresenter onSubject: self
)
public isKindOfHomeSubject ^ <Boolean> = (
	^true
)
lateNightWisdom = (
	|
	now = DateTime nowLocal.
	hour = now hour - 1 \\ 12 + 1. (* 0 -> 12 *)
	minute = now minutes.
	time = hour asString, (minute < 10 ifTrue: [':0'] ifFalse: [':']), minute asString.
	|
	^BitOfWisdom text: 'It''s ', time, '. Go get some rest!'
)
public randomBitOfWisdom = (
	| bits |
	DateTime nowLocal hour < 5 ifTrue: [^lateNightWisdom].
	bits:: bitsOfWisdom.
	^(bits at: (random nextInteger: bits size) + 1) value
)
public title = (
	^'Home'
)
) : (
public new = (
	^onModel: nil
)
)
class IntegerView onSubject: s = ProgrammingPresenter onSubject: s (
) (
definition = (
	^column: {
		label: 'binary' radix: 2.
		label: 'octal' radix: 8.
		label: 'decimal' radix: 10.
		label: 'hex' radix: 16.
	}
)
label: label radix: radix = (
	^row: {
		smallBlank.
		(label: label)
			width: 0 elasticity: 1.
		smallBlank.
		(label: (subject objectMirror reflectee asStringRadix: radix))
			width: 0 elasticity: detailAreaRatio.
	}
)
) : (
)
class JSAlienView onSubject: s = ProgrammingPresenter onSubject: s (
) (
definition = (
	^column:
		(subject jsProperties collect:
			[:slot <SlotSubject> | slot presenter])
)
public title = (
	^'JavaScript'
)
) : (
)
class KeysAndValuesView title: t onSubject: s = ProgrammingPresenter onSubject: s (
	|
	public title <String> = t.
	|
) (
definition = (
	^column:
		(subject keysAndValues collect:
			[:slot <SlotSubject> | slot presenter])
)
) : (
)
class MemberPresenter onSubject: s = ProgrammingPresenter onSubject: s (
	|
	public showClassName ::= false.
	|
) (
accessIndicator = (
	^image: (iconForAccessModifier: subject accessModifier).
)
actionMenu = (
	^dropDownMenu:
		[menuWithLabelsAndActions:
			{{'Delete ', subject name. [subject delete. refresh]}.
			 {'Inspect Presenter'. [respondToInspectPresenter]}}]
)
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> | | cp <Integer> |
		colorizeSource: ed textBeingAccepted withEditor: ed.
		ed enterEditState.
	 ]
)
public collapse = (
	^substance collapse
)
definition ^<Fragment> = (
	| toggle |
	toggle::
		collapsed:
			[heading: [toggle expand]]
		expanded:
			[column: {
				heading: [toggle collapse].
				editor.
			}].
	^toggle
)
editor ^<Fragment> = (
	| src = subject source. cm = codeMirror: src. |
	cm changeResponse: changeResponse; acceptResponse: acceptResponse.
	colorizeSource: src withEditor: cm.
	^cm
)
public expand = (
	^substance expand
)
heading: action ^<Fragment> = (
	showClassName ifTrue:
		[^row: {
			accessIndicator.
			smallBlank.
			(link: subject name action: action) color: actionLinkColor.
			nestingInformationLine.
			filler.
			referencesMenu.
			smallBlank.
			actionMenu.
			smallBlank.
		}].

	^row1: {
		accessIndicator.
		smallBlank.
		(link: subject name action: action) color: actionLinkColor.
	} row2: {
		(label: subject commentSummary)
			expansibility: 1;
			compressibility: 1;
			color: secondaryTextColor;
			smallFont.
		mediumBlank.
		referencesMenu.
		smallBlank.
		actionMenu.
		smallBlank.
	}
)
linkToBrowseEnclosing: mixin <MixinMirror> = (
	^(link: mixin name
		action: [browseMixinMirror: mixin])
		color: secondaryTextColor
)
nestingInformationLine = (
	| enclosingClasses rowElements |
	enclosingClasses:: subject enclosingClasses.
	rowElements:: List new.
	enclosingClasses do:
		[:each |
		rowElements add: ((label: ' in ') color: tertiaryTextColor).
		rowElements add: (linkToBrowseEnclosing: each)].
	^row: rowElements asArray
)
referencesMenu = (
	^referencesMenu:
		[menuWithLabelsAndActions:
			(subject messages collect:
				[:selector | { selector. [navigateToSelector: selector] }])]
)
row1: row1 row2: row2 = (
	^row: {
		(row: row1) width: 0 elasticity: 1.
		(row: {mediumBlank}, row2) width: 0 elasticity: 2.
	}
)
) : (
)
(* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)
class MethodGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
) (
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	addNewItemTemplate: subject methodTemplateText
)
addNewItemTemplate: src = (
	(* Handle a user's request to create a new method by displaying a new method template. *)

	| template |
	template:: DefinitionTemplate
		caption: 'Adding new method:'
		initialText: src
		colorizerBlock:
			[:text <String> :cm <CodeMIrrorFragment> | subject colorizeSource: text editor: cm]
		acceptResponse:
			[:ed | createNewMethodFromTemplate: template]
		cancelResponse:
			[:ed | prefixes remove: template].
	prefixes add: template.
	prefixes refresh.
	^template
)
createNewMethodFromTemplate: template <DefinitionTemplate> = (
	subject
		compileSource: template text
		ifSuccess:
			[:newMethod <MethodMirror> |
			|
			newSubject <MethodSubject> = MethodSubject onModel: newMethod.
			newPresenter <MethodPresenter> = createPresenterForSubject: newSubject.
			|
			prefixes remove: template.
			content add: newPresenter.
			newPresenter expand]
		ifFailure:
			[:message | template editor showMessage: message]
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^MethodPresenter
)
) : (
)
(* Represents the collection of methods of a Newspeak class. Holds onto the mirror group for the methods. *)
public class MethodGroupSubject onModel: m <MirrorGroup[MethodMirror]> within: dm <MixinMirror> = MirrorGroupSubject onModel: m within: dm  (
) (
public colorizeSource: source <String> editor: cm <CodeMirrorFragment> ^ <TextFragment> = (
	^ide colorizer
		colorizeMethod: source
		fromMixin: definingMixin
		via: (colorizingBlockFor: cm)
)
public compileSource: source <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <MethodBuilder> newMirror <MethodMirror> |
	builder:: definingMixin asBuilder.
	newBuilder:: builder methods addFromSource: source.
	builder declaration install.
	newMirror:: definingMixin methods findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Exception
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public createPresenter = (
	^MethodGroupPresenter onSubject: self
)
elementSubjectClass ^ <MethodSubject class> = (
	^MethodSubject
)
public methodTemplateText ^ <String> = (
^
'messageSelector = (
)'
)
modelMirrorCollection ^ <Collection[MethodMirror]> = (
	^super modelMirrorCollection (*asSortedList: [:a :b | a simpleName < b simpleName]*)
)
) : (
)
(* A presenter for a single method. *)
class MethodPresenter onSubject: s <MethodSubject> = MemberPresenter onSubject: s (
) (
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		b methods addFromSource: ed textBeingAccepted.
		b declaration install.
		colorizeSource: ed textBeingAccepted withEditor: ed.
		ed leaveEditState.
		]
)
colorizeSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeMethod: s fromMixin: subject methodMirror definingMixin via: (colorizingBlockFor: cm)
)
) : (
)
(* Manages the UI for a method. *)
public class MethodSubject onModel: mm <MethodMirror> = Subject onModel: mm (
) (
public accessModifier ^ <Symbol> = (
	^methodMirror accessModifier
)
public classDeclaration ^ <ClassDeclarationMirror> = (
	^methodMirror definingMixin declaration
)
public commentSummary ^<String> = (
	^summarizeCommentFromMetadata: model metadata
)
public createPresenter ^ <Presenter> = (
	^MethodPresenter onSubject: self
)
public delete = (
	| b <MixinBuilder> = methodMirror definingMixin asBuilder. |
	b methods removeMirrorNamed: methodMirror name.
	b declaration install.
)
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
public enclosingClasses ^<List[MixinMirror]> = (
	| classes currentClass |
	classes:: List new.
	currentClass:: methodMirror definingMixin.
	[classes add: currentClass.
	 currentClass:: currentClass declaration enclosingClass.
	 currentClass isNil]
		whileFalse: [currentClass:: currentClass instanceSide].
	^classes
)
public messages = (
	^List new
		addAll: ((methodMirror metadata collect: [:ea | ea tag]) reject: [:ea | nil = ea]);
		addAll: methodMirror selectors;
		sort: [:a :b | lexicallyLessOrEqual: a than: b];
		addFirst: methodMirror name;
		yourself
)
public methodMirror ^ <MethodMirror> = (
	^model
)
public name ^ <Symbol> = (
	^methodMirror name
)
public source ^ <String> = (
	^methodMirror source
)
) : (
)
class MirrorGroupPresenter onSubject: s <Subject> = DefinitionListPresenter onSubject: s (
) (
public addNewItemTemplate = (
	(* A subclass must redefine this to show a template for the user to fill out to create a new item in the group. *)

	subclassResponsibility
)
contentPresenters ^ <Collection[ProgrammingPresenter]> = (
	^subject elements collect:
		[:each <ProgrammingPresenter> | createPresenterForSubject: each]
)
createPresenterForSubject: aSubject <Subject> ^ <ProgrammingPresenter> = (
	(* Let the subject create its default unless elementPresenterClass is set to specify our preference. *)
	nil = elementPresenterClass ifTrue: [^aSubject presenter].
	^elementPresenterClass onSubject: aSubject
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	(* A subclass must redefine this to define the class of presenter it will be using. *)
	subclassResponsibility
)
) : (
)
class MirrorGroupSubject onModel: m <MirrorGroup> within: dm <MixinMirror> = Subject onModel: m (
	|
	public definingMixin <MixinMirror> = dm.
	|
) (
elementSubjectClass = (
	(* Answer the class of the subjects we create on individual elements of our subject group. *)
	subclassResponsibility
)
public elements ^<Collection[Subject]> = (
	(* Answer a collection of subjects on individual elements of the group which is our subject. *)
	^modelMirrorCollection collect: [:each | elementSubjectClass onModel: each]
)
public mirrorGroup ^ <MirrorGroup> = (
	^model
)
modelMirrorCollection ^<Collection[Mirror]> = (
	^List withAll: model
)
) : (
)
class NamespacePresenter onSubject: s = DefinitionListPresenter onSubject: s (
) (
class ClassEntryPresenter onSubject: s <ClassSubject> = EntryPresenter onSubject: s () (
collapsedDefinition = (
	^row1: {
		image: ide images classIcon.
		smallBlank.
		link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror].
	} row2: {
		(label: subject commentSummary)
			expansibility: 1;
			compressibility: 1;
			color: secondaryTextColor;
			smallFont.
		ClassActionsPresenter onSubject: subject.
		mediumBlank.
		entryActionsMenu.
	}
)
entryActionsMenu = (
	^dropDownMenu: [entryActionsMenuFor: subject name].
)
expandedDefinition = (
	^subject presenter
)
) : (
)
class NamespaceEntryPresenter onSubject: s = EntryPresenter onSubject: s () (
collapsedDefinition = (
	^row1: {
		image: ide images classPresenterIcon.
		smallBlank.
		smallBlank.
		row: {link: subject key action: [
			(*ide defaultPopularityRecord
			rememberNamespaceVisit: subject key. (* Should be the namespace itself, but non-strings break the home page. *)*)
			enterSubject:: subject refreshmentSubject]}.
	} row2: {
		(label: subject summaryText)
			expansibility: 1;
			compressibility: 1;
			color: secondaryTextColor;
			smallFont.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: subject key]
	}.
)
expandedDefinition = (
	^subject presenter
)
) : (
)
class ValueEntryPresenter onSubject: s = EntryPresenter onSubject: s (|
	public key
|) (
collapsedDefinition = (
	^row1: {
		image: ide images classUnknownIcon.
		smallBlank.
		link: key action: [enterSubject:: subject].
	} row2: {
		(label: subject title)
			expansibility: 1;
			compressibility: 1;
			color: secondaryTextColor;
			smallFont.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: key]
	}
)
definition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^collapsed: [collapsedDefinition]
	expanded: [subject presenter selfCaption: key]
)
expandedDefinition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^subject presenter selfCaption: key
)
) : (
)
acceptNewClassDefinitionFrom: aTemplate = (
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate.
			 content setPresenters: contentPresenters]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
acceptNewNamespaceDefinitionFrom: aTemplate = (
	subject
		addNamespaceFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate.
			 content setPresenters: contentPresenters]
		ifFailure:
			[:msg | aTemplate editor text: msg]
)
addCategoryMenu = (
	^ {
		{'Add Class'. [addClassTemplate]}.
		{ 'Add Namespace'. [addNamespaceTemplate]}.
		(*{'Add Image From File'. [respondToAddImage].}.
		{'Add Text From File'. [respondToAddText]}.
		 'Add Value' -> [Exeption signal: 'Unimplemented']. *)
	}
)
addClassTemplate = (
	prefixes add:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: subject classTemplateText
			colorizerBlock:
				[:text <String> :cm <CodeMIrrorFragment> | subject colorizeClassSource: text editor: cm]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | prefixes remove: template]).
	prefixes refresh.
)
addNamespaceTemplate = (
	prefixes add:
		(DefinitionTemplate
			caption: 'Defining a new namespace:'
			initialText: 'NewNamespace'
			colorizerBlock:
				[:text <String> :cm <CodeMIrrorFragment> | ]
			acceptResponse:
				[:template | acceptNewNamespaceDefinitionFrom: template]
			cancelResponse:
				[:template | prefixes remove: template]).
	prefixes refresh.
)
contentList ^ <PresenterList> = (
	^zebra: super contentList
)
contentPresenters ^ <List[Presenter]> = (
	| lexicalOrder <[:Symbol :Symbol | Boolean]> |
	lexicalOrder:: [:a <Symbol> :b <Symbol> |
		lexicallyLessOrEqual: a than: b
	].
	^(subject namespace keys asArray sort: lexicalOrder) collect: [:key | presenterForEntryAt: key]
)
definition ^ <Fragment> = (
	^column: {
		minorHeadingBlock: (row: {
			label: subject key (*asText allBold*).
			largeBlank.
			(*subject namespace isKindOfCategoryNamespace
				ifTrue: [*)addButtonWithMenu: [addCategoryMenu](*]
				ifFalse: [addButtonWithAction: [respondToAddForRoot]]*).
			filler.
			expandButtonWithAction: [expandAll].
			blank: 3.
			collapseButtonWithAction: [collapseAll].
			blank: 3.
			dropDownMenu: [namespaceMenu].
			largeBlank.
			homeButton.
			smallBlank.
			refreshButton.
		}).
		smallBlank.
		super definition.
	}
)
entryActionsMenuFor: key = (
	^menuWithLabelsAndActions: {
		{'Remove ', key. [ide namespacing removeKey: key.  refresh]}.
	}
)
namespaceMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
presenterForEntryAt: key <Symbol> ^ <EntryPresenter> = (
	| entry = subject namespace at: key. |
	entry isKindOfBehavior
		ifTrue: [^ClassEntryPresenter onSubject: (ClassSubject onModel: (ClassMirror reflecting: entry) mixin declaration)].

	entry isKindOfNamespace
		ifTrue: [^NamespaceEntryPresenter onSubject: (NamespaceSubject onModel: entry key: key)].

	^(ValueEntryPresenter onSubject: (objectSubjectFor: entry)) key: key
)
respondToAddForRoot = (
	openMenuWithLabelsAndActions: {
		{'Add Namespace'. [addNamespaceTemplate]}.
	}
)
respondToAddImage = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Image files (*.png)' ->'*.png'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key form |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		form:: PNGReadWriter formFromFileNamed: fn.
		subject namespace at: key asSymbol put: form.
	].
)
respondToAddText = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Text files (*.txt)' ->'*.txt'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key text |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		text:: ((MultiByteFileStream oldFileNamed: fn)
			converter: (TextConverter newForEncoding: 'utf8')) contents.
		subject namespace at: key asSymbol put: text.
	].
)
) : (
)
public class NamespaceSubject onModel: m <Map[Symbol, Object]> key: k <Symbol> = Subject onModel: m (|
	public key = k.
|) (
public = other ^<Boolean> = (
	^class = other class (* class is not public *)
		and: [namespace = other namespace]
		and: [key = other key].
)
public addClassFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| builder <ClassDeclarationBuilder> klass |
	[builder:: ClassDeclarationBuilder fromSource: definition]
		on: Exception
		do: [:ex | ^failureBlock value: ex printString].
	(namespace includesKey: builder name) ifTrue:
		[^failureBlock value: 'A class named ', builder name, ' already exists in this namespace'].
	klass:: builder install applyToObject.
	namespace at: klass mixin name put: klass reflectee.
	successBlock value
)
public addNamespaceFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| selector <Symbol> = definition asSymbol. |

	(namespace includesKey: selector) ifTrue:
		[^failureBlock value: 'A class named ', definition, ' already exists in this namespace'].
	namespace at: selector put: (ide namespacing freshNamespace).
	successBlock value
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
	|
	slot1
	slot2
	|
) ()'
)
public colorizeClassSource: source <String> editor: cm <CodeMirrorFragment>  = (
	^ide colorizer
		colorizeClassDeclaration: source
		fromMixin: nil
		via: (colorizingBlockFor: cm)
)
public createPresenter ^ <NamespacePresenter> = (
	^NamespacePresenter onSubject: self
)
public hash ^<Integer> = (
	^model hash bitXor: key hash
)
public namespace ^ <Map[Symbol, Object]> = (
	^self model
)
public refreshmentSubject = (
	^self class onModel: model key: key
)
public summaryText = (
	| sb = StringBuilder new. |
	namespace keys
		do: [:k | sb add: k]
		separatedBy: [sb add: ', '].
	^sb asString
)
public title ^<String> = (
	^key
)
) : (
public new = (
	#NAMESPACEBOGUS.
	^self onModel: ide namespacing Root key: 'Root'
)
)
(* Presents the subject, a NestedClassGroupSubject, as a column of presenters for the nested classes in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS nested classes goes here. *)
class NestedClassGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
) (
acceptNewClassDefinitionFrom: aTemplate = (
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[:newClass <ClassDeclarationMirror> |
			|
			newSubject <ClassSubject> = ClassSubject onModel: newClass.
			newPresenter <NestedClassPresenter> = createPresenterForSubject: newSubject.
			|
			prefixes remove: aTemplate.
			content add: newPresenter.
			newPresenter expand]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
public addNewItemTemplate = (
	(* Handle a user's request to create a new nested class by displaying a new class template. *)
	prefixes add:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: subject classTemplateText
			colorizerBlock:
				[:text <String> :cm <CodeMIrrorFragment> | subject colorizeClassSource: text editor: cm]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | prefixes remove: template]).
	prefixes refresh.
)
public deleteClassInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	subject deleteClassWithSubject: presenter subject.
	successResponse value
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^NestedClassPresenter
)
) : (
)
(* Represents the collection of nested classes of a Newspeak class. Holds onto the mirror group for the classes. *)
public class NestedClassGroupSubject onModel: m <MirrorGroup[ClassDeclarationMirror]> within: dm <MixinMirror> = MirrorGroupSubject onModel: m within: dm  (
) (
public addClassFromDefinition: source <String> ifSuccess: successBlock <[:ClassDeclarationMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <ClassDeclarationBuilder> newMirror <ClassDeclarationMirror> |
	builder:: definingMixin asBuilder.
	newBuilder:: builder nestedClasses addFromSource: source.
	builder declaration install.
	newMirror:: definingMixin nestedClasses findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Exception
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
	|
	slot1
	slot2
	|
) ()'
)
public colorizeClassSource: source <String> editor: cm <CodeMirrorFragment> = (
	^ide colorizer
		colorizeClassDeclaration: source
		fromMixin: definingMixin
		via: (colorizingBlockFor: cm)
)
public createPresenter = (
	^NestedClassGroupPresenter onSubject: self
)
public deleteClassWithSubject: classSubject <ClassSubject> = (
	| builder <MixinBuilder> |
	builder:: definingMixin asBuilder.
	builder nestedClasses removeMirrorNamed: classSubject name.
	builder declaration install.
)
elementSubjectClass ^ <ClassSubject class> = (
	^ClassSubject
)
) : (
)
class NestedClassPresenter onSubject: s <ClassSubject> = MemberPresenter onSubject: s () (
collapsedDefinition = (
	^row1: {
		accessIndicator.
		smallBlank.
		link: subject name action: [enterSubject:: subject].
	} row2: {
		(label: subject commentSummary)
			expansibility: 1;
			compressibility: 1;
			color: secondaryTextColor;
			smallFont.
		mediumBlank.
		referencesMenu.
		smallBlank.
		actionMenu.
		smallBlank.
	}
)
definition ^<Fragment> = (
	^collapsed: [collapsedDefinition] expanded: [subject presenter]
)
) : (
)
class ObjectPresenter onSubject: s = ProgrammingPresenter onSubject: s (
	|
	public selfCaption ::= 'self'.
	|
) (
actionsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Mirror'. [respondToInspectMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
		{'References to this object'. [respondToReferences]}.
	}
)
availableObjectViews = (
	subject isModelKindOfInteger ifTrue:
		[^{IntegerView onSubject: subject}].
	subject isModelKindOfString ifTrue:
		[^{StringView onSubject: subject. BasicView onSubject: subject}].
	subject isModelKindOfJSAlien ifTrue:
		[^{JSAlienView onSubject: subject. BasicView onSubject: subject}].

	subject isModelKindOfList ifTrue:
		[^{KeysAndValuesView title: 'List' onSubject: subject. BasicView onSubject: subject}].
	subject isModelKindOfMap ifTrue:
		[^{KeysAndValuesView title: 'Map' onSubject: subject. BasicView onSubject: subject}].

	^{BasicView onSubject: subject}
)
captionBar: body = (
	^(padded: body with: {5. 5. 5. 5}) color: captionColor
)
classInfoLine = (
	^row: {
		(label: 'class')
			width: 0 elasticity: 1.
		(link: subject className action: [navigateToClass])
			width: 0 elasticity: detailAreaRatio.
	}
)
definition = (
	^column: {
		captionBar: (column: {
			selfInfoLine.
			classInfoLine.
			smallBlank.
			EvaluationPresenter onSubject: subject.
		}).
		objectDetails.
	}
)
navigateToClass = (
	enterSubject: subject classSubject.
)
navigateToSelf = (
	enterSubject: (ObjectSubject onModel: subject objectMirror)
)
objectDetails = (
	| views = availableObjectViews. currentView switchers |
	views size = 1 ifTrue: [^views first].
	currentView:: holder: views first.
	switchers:: List new.
	views do:
		[:view |
		 switchers add: mediumBlank.
		 switchers add: ((link: '[', view title, ']' action: [currentView content: view]) color: actionLinkColor)].
	^column: {
		row: switchers.
		currentView.
	}
)
respondToInspectMirror = (
	inspectObject: subject objectMirror.
)
respondToReferences = (
	shell enterPresenter: ((ReverseObjectPresenter onSubject: subject) selfCaption: 'references to').
)
selfInfoLine = (
	^row: {
		(label: selfCaption (*asText allBold*)) width: 0 elasticity: 1.
		(row: {
			(link: subject title action: [navigateToSelf]) compressibility: 1.
			filler compressibility: 0.
			mediumBlank.
			dropDownMenu: [actionsMenu].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public title = (
	^'Inspector on ', subject title
)
) : (
)
public class ObjectSubject onModel: m = Subject onModel: m (
) (
public classMirror ^<ClassMirror> = (
	^model getClass
)
public className ^<String> = (
	^classMirror mixin name
)
public classSubject = (
	^ClassSubject onModel: classMirror mixin declaration
)
public createPresenter = (
	^ObjectPresenter onSubject: self
)
public evaluate: expression <String> suspended: suspended <Boolean> ^<ThreadMirror> = (
	| thread |
	thread:: objectMirror evaluateSuspended: expression with: ide theWorkspaceManager evaluationScope.
	suspended ifFalse: [thread resume].
	^thread
)
public isModelKindOfArray ^<Boolean> = (
	classMirror = (ClassMirror reflecting: Array) ifTrue: [^true].
	classMirror = (ClassMirror reflecting: WeakArray) ifTrue: [^true].
	^false
)
public isModelKindOfInteger ^<Boolean> = (
	(* bogus - should not send message to inspectee *)
	^objectMirror reflectee isKindOfInteger
)
public isModelKindOfJSAlien ^<Boolean> = (
	(* bogus - should not send message to inspectee *)
	^objectMirror reflectee isKindOfJSAlien
)
public isModelKindOfList ^<Boolean> = (
	^classMirror = (ClassMirror reflecting: List)
)
public isModelKindOfMap ^<Boolean> = (
	classMirror = (ClassMirror reflecting: Map) ifTrue: [^true].
	^false
)
public isModelKindOfString ^<Boolean> = (
	^classMirror = (ClassMirror reflecting: String)
)
public jsProperties ^<Collection[SlotSubject]> = (
	| result propertyNames |
	result:: List new.
	(* Object.getPrototypeOf(undefined) throws *)
	objectMirror reflectee isUndefined ifTrue: [^result].
	result add:
		(SlotSubject name: '[[Prototype]]' value:
			(ObjectMirror reflecting: (JSObject getPrototypeOf: objectMirror reflectee))).
	propertyNames:: JSObject getOwnPropertyNames: objectMirror reflectee.
	0 to: (propertyNames at: #length) - 1 do:
		[:index |
		 |
		 name = propertyNames at: index.
		 descriptor = JSObject getOwnPropertyDescriptor: objectMirror reflectee with: name.
		 |
		 descriptor isUndefined ifFalse:
			[result add:
				(SlotSubject name: name value:
					(ObjectMirror reflecting: (descriptor at: #value)))]].
	^result
)
public keysAndValues ^<Collection[SlotSubject]> = (
	| result |
	result:: List new: objectMirror reflectee size.
	objectMirror reflectee keysAndValuesDo:
		[:key :value | result add:
			(SlotSubject
				name: 'at: ', key printString
				value: (ObjectMirror reflecting: value))].
	result addFirst:
		(SlotSubject
			name: 'size'
			value: (ObjectMirror reflecting: result size)).
	^result
)
public objectMirror ^<ObjectMIrror> = (
	^model
)
public references ^<Collection[SlotSubject]> = (
	| result |
	result:: List new.
	objectMirror referringObjects reflectee do:
		[:referringObject |
		 | m = ObjectMirror reflecting: referringObject. |
		 m getClass = objectMirror ifTrue:
		 	[result add:
				(SlotSubject name: '<class>' value: m)].
		 m slots do:
			[:slot |
			 slot value = objectMirror ifTrue:
				[result add:
					(SlotSubject name: slot name value: m)]]].
	^result
)
public slots ^<Collection[SlotSubject]> = (
	| result enclosing |
	result:: List new.

	enclosing:: classMirror mixin declaration enclosingClass.
	nil = enclosing ifFalse:
		[result add: (SlotSubject
			name: 'outer ' , enclosing name
			value: classMirror enclosingObject)].
	result addAll: slotsX.
	^result
)
slotsX ^<Collection[SlotSubject]> = (
	^objectMirror slots collect:
		[:slotMirror | | name ::= slotMirror name. |
		 name isKindOfInteger ifTrue: [name:: 'at: ', name asString].
		 SlotSubject name: name value: slotMirror value]
)
public title = (
	^objectMirror reflectee printString
)
) : (
)
(* Common superclass for presenters of programming constructs. *)
public class ProgrammingPresenter onSubject: s <Subject> = Presenter onSubject: s (
) (
actionLinkColor = (
	^Color h: 31 s: 0.85 v: 0.40
)
addButtonWithAction: aBlock = (
	^imageButton:
		{ide images addImage.
		ide images addOverImage.
		ide images addOutImage}
	action: aBlock
)
addButtonWithMenu: menu = (
	^dropDownMenu: menu
		images: {
		   ide images addImage.
		   ide images addOverImage.
		   ide images addOutImage
		}
)
browseClass: klass <Behavior> = (
	enterSubject:: ClassSubject onModel: (ClassMirror reflecting: klass) mixin declaration.
)
browseMixinMirror: mixin <MixinMirror> = (
	enterSubject:: ClassSubject onModel: mixin declaration.
)
collapseButtonWithAction: aBlock = (
	^imageButton:
		{ide images collapseImage.
		 ide images collapseOverImage.
		 ide images collapseDownImage}
	action: aBlock
)
expandButtonWithAction: aBlock = (
	^imageButton:
		{ide images expandImage.
		 ide images expandOverImage.
		 ide images expandDownImage}
	action: aBlock
)
homeButton = (
	^imageButton: {
		ide images homeImage.
		ide images homeOutImage.
		ide images homeOverImage.
		ide images homeDownImage
		}
		action: [enterSubject: HomeSubject new].
)
iconForAccessModifier: am = (
	#private = am ifTrue: [^ide images privateAccessImage].
	#protected = am ifTrue: [^ide images protectedAccessImage].
	^ide images publicAccessImage
)
indentedBlock: body = (
	^column: {
		mediumBlank.
		row: {
			mediumBlank.
			elastic: body
			}.
		mediumBlank
		}
)
inspectObject: object <Object> = (
	enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: object).
)
inspectObjectMirror: object <ObjectMirror> = (
	enterSubject:: ObjectSubject onModel: object.
)
majorHeadingBlock: body = (
	^(padded: body with: {10. 10. 10. 10.})
		color: majorHeadingColor
)
majorHeadingColor = (
	(* This color is used for major definitions such as class headings. *)
	^Gradient
		from: (Color h: 41 s: 0.20 v: 0.85)
		to: (Color h: 41 s: 0.20 v: 0.75)
)
minorHeadingBlock: body = (
	^(padded: body with: {10. 5. 10. 5.})
		color: minorHeadingColor
)
minorHeadingColor = (
^Gradient
	from: (Color h: 41 s: 0.20 v: 0.90)
	to: (Color h: 41 s: 0.20 v: 0.80)
)
navigateToSelector: selector <String> = (
	ide namespacing reindex.
	enterSubject:: ide namespacing SelectorSubject onModel: selector.
)
public objectSubjectFor: anObject = (
	^objectSubjectForMirror: (ObjectMirror reflecting: anObject)
)
objectSubjectForMirror: objectMirror <ObjectMirror> = (
	^ObjectSubject onModel: objectMirror
)
referencesMenu: menu = (
	^dropDownMenu: menu images: {ide images itemReferencesImage}
)
refreshButton = (
	^imageButton: {
		ide images refreshImage.
		ide images refreshOutImage.
		ide images refreshOverImage.
		ide images refreshDownImage
		}
		action: [shell refresh].
)
respondToInspectPresenter = (
	inspectObject: self.
)
secondaryTextColor ^ <Color> = (
	^Color h: 31 s: 0.85 v: 0.60
)
tertiaryTextColor = (
	^Color h: 31 s: 0.85 v: 0.80
)
) : (
)
class ReverseObjectPresenter onSubject: s = ObjectPresenter onSubject: s (
) (
definition = (
	^column: {
		captionBar: (column: {
			selfInfoLine.
		}).
		objectDetails.
	}
)
objectDetails = (
	^column:
		(subject references collect:
			[:slot <SlotSubject> | ReverseSlotPresenter onSubject: slot])
)
public title = (
	^'References to ', subject title
)
) : (
)
class ReverseSlotPresenter onSubject: s = SlotPresenter onSubject: s (
) (
details ^<Fragment> = (
	^(ReverseObjectPresenter onSubject: (objectSubjectForMirror: subject objectMirror))
		selfCaption: subject name
)
) : (
)
class SlotPresenter onSubject: s <SlotSubject> = ProgrammingPresenter onSubject: s (
) (
caption ^<Fragment> = (
	^row: {
		(link: subject name action: [substance toggle])
			width: 0 elasticity: 1;
			color: actionLinkColor.
		smallBlank.
		(link: subject reflecteePrintString action: [inspectObjectMirror: subject objectMirror])
			width: 0 elasticity: detailAreaRatio.
	}
)
definition ^<Fragment> = (
	^collapsed: [caption] expanded: [details]
)
details ^<Fragment> = (
	^(objectSubjectForMirror: subject objectMirror) presenter selfCaption: subject name
)
) : (
)
public class SlotSubject name: n value: v = Subject onModel: v (
	|
	public name = n.
	|
) (
public createPresenter = (
	^SlotPresenter onSubject: self
)
public objectMirror ^<ObjectMirror> = (
	^model
)
public reflecteePrintString = (
	^model reflectee printString
)
) : (
)
class StringView onSubject: s = ProgrammingPresenter onSubject: s (
) (
definition = (
	| editor |
	editor:: TextEditorFragment new.
	editor text: subject objectMirror reflectee.
	^column: {
		editor
	}
)
public title = (
	^'String'
)
) : (
)
(* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)
class TransientSlotGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
) (
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	addNewItemTemplate: subject methodTemplateText
)
addNewItemTemplate: src = (
	(* Handle a user's request to create a new method by displaying a new method template. *)

	| template |
	template:: DefinitionTemplate
		caption: 'Adding new transient slot'
		initialText: src
		colorizerBlock:
			[:text <String> :cm <CodeMIrrorFragment> | subject colorizeSource: text editor: cm]
		acceptResponse:
			[:ed | createNewTransientSlotFromTemplate: template]
		cancelResponse:
			[:ed | prefixes remove: template].
	prefixes add: template.
	prefixes refresh.
	^template
)
createNewTransientSlotFromTemplate: template <DefinitionTemplate> = (
	subject
		compileSource: template text
		ifSuccess:
			[:newTransientSlot <MethodMirror> |
			|
			newSubject <MethodSubject> = TransientSlotSubject onModel: newTransientSlot.
			newPresenter <MethodPresenter> = createPresenterForSubject: newSubject.
			|
			prefixes remove: template.
			content add: newPresenter.
			newPresenter expand]
		ifFailure:
			[:message | template editor showMessage: message]
)
public deleteTransientSlotInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	subject deleteTransientSlotWithSubject: presenter subject.
	successResponse value
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^TransientSlotPresenter
)
) : (
)
(* Represents the collection of transient slots of a Newspeak class. Holds onto the mirror group for the transient slots. *)
public class TransientSlotGroupSubject onModel: m <MirrorGroup[TransientSlotMirror]> within: dm <MixinMirror> = MirrorGroupSubject onModel: m within: dm  (
) (
public colorizeSource: source <String> editor: cm <CodeMirrorFragment> ^ <TextFragment> = (
	^ide colorizer
		colorizeTransientSlot: source
		fromMixin: definingMixin
		via: (colorizingBlockFor: cm)
)
public compileSource: source <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <MethodBuilder> newMirror <MethodMirror> |
	builder:: definingMixin asBuilder.
	newBuilder:: builder transientSlots addFromSource: source.
	builder declaration install.
	newMirror:: definingMixin transientSlots findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Exception
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public createPresenter = (
	^TransientSlotGroupPresenter onSubject: self
)
elementSubjectClass ^<TransientSlotSubject class> = (
	^TransientSlotSubject
)
public methodTemplateText ^ <String> = (
^
'transient slotName = initializer.'
)
modelMirrorCollection ^<Collection[TransientSlotMirror]> = (
	^super modelMirrorCollection (*asSortedList: [:a :b | a simpleName < b simpleName]*)
)
) : (
)
class TransientSlotPresenter onSubject: s <TransientSlotSubject> = MemberPresenter onSubject: s (
) (
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <MixinBuilder> = subject transientSlotMirror definingMixin asBuilder. |
		b transientSlots addFromSource: ed textBeingAccepted.
		b declaration install.
		colorizeSource: ed textBeingAccepted withEditor: ed.
		ed leaveEditState.
		]
)
colorizeSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeTransientSlot: s fromMixin: subject transientSlotMirror definingMixin via: (colorizingBlockFor: cm)
)
) : (
)
public class TransientSlotSubject onModel: tsm <TransientSlotMirror> = Subject onModel: tsm (
) (
public accessModifier ^<Symbol> = (
	^transientSlotMirror accessModifier
)
public classDeclaration ^<ClassDeclarationMirror> = (
	^transientSlotMirror definingMixin declaration
)
public commentSummary ^<String> = (
	^summarizeCommentFromMetadata: model metadata
)
public createPresenter ^<Presenter> = (
	^TransientSlotPresenter onSubject: self
)
public delete = (
	| b <MixinBuilder> = transientSlotMirror definingMixin asBuilder. |
	b transientSlots removeMirrorNamed: transientSlotMirror name.
	b declaration install.
)
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
public enclosingClasses ^<List[MixinMirror]> = (
	| classes currentClass |
	classes:: List new.
	currentClass:: transientSlotMirror definingMixin.
	[classes add: currentClass.
	 currentClass:: currentClass declaration enclosingClass.
	 currentClass isNil]
		whileFalse: [currentClass:: currentClass instanceSide].
	^classes
)
public messages = (
	| result |
	result:: List withAll: transientSlotMirror selectors.
	result sort: [:a :b | lexicallyLessOrEqual: a than: b].
	model isMutable ifTrue: [result addFirst: model name, ':'].
	result addFirst: model name.
	result addAll: ((transientSlotMirror metadata collect: [:ea | ea tag]) reject: [:ea | nil = ea]).
	^result
)
public name ^<Symbol> = (
	^transientSlotMirror name
)
public source ^<String> = (
	^transientSlotMirror source
)
public transientSlotMirror ^<TransientSlotMirror> = (
	^model
)
) : (
)
colorizingBlockFor: cm <CodeMirrorFragment> = (
	^[:r | | style <Alien[JSObject]> = JSObject new. |
	style at: 'css' put: (cssFor: r kind).
	cm style: style from: r start to: r end]
)
cssConversionTable ^ <Map[Symbol, String]> = (
(* compute a mapping from 'kinds', which are symbols denoting logical categories of code, to CSS properties used to colorize them*)
	|
	redBoldUnderlined <String> = 'color:Red; font-weight:bold; text-decoration: underline'.
	redUnderlined <String> = 'color:Red; text-decoration: underline'.
	orangeBoldUnderlined <String> = 'color:Orange; font-weight:bold; text-decoration: underline'.
	underlined <String> = 'text-decoration: underline'.
	gray <String> = 'color:Gray'.
	blue <String> = 'color:Blue'.
	grayBold <String> = 'color:Gray; font-weight:bold'.
	blackBold <String> = 'color:Black; font-weight:bold'.
	blueBold <String> = 'color:Blue; font-weight:bold'.
	magentaBold <String> = 'color:Magenta; font-weight:bold'.
	bold <String> = 'font-weight:bold'.
	|
      ^Map new
		at: #error put: redBoldUnderlined;
		at: #undefinedUnary put: redUnderlined;
		at: #undefinedBinary put: redUnderlined;
		at: #undefinedKeyword put: redUnderlined;
		at: #shadowingTempVar put: orangeBoldUnderlined;
		at: #obsoleteMessage put: orangeBoldUnderlined;
		at: #whitespaceWarning put: orangeBoldUnderlined;
		at: #incompleteUnary put: underlined;
		at: #incompleteBinary put: underlined;
		at: #incompleteKeyword put: underlined;
		at: #self put: gray;
		at: #super put: gray;
		at: #outer put: gray;
		at: #true put: gray;
		at: #false put: gray;
		at: #nil put: gray;
		at: #string put: gray;
		at: #symbol put: gray;
		at: #number put: gray;
		at: #character put: gray;
		at: #public put: gray;
		at: #protected put: gray;
		at: #private put: gray;
		at: #tempVar put: grayBold;
		at: #blockTempVar put: grayBold;
		at: #blockPatternArg put: grayBold;
		at: #patternArg put: grayBold;
		at: #slotDecl put: grayBold;
		at: #patternTempVar put: grayBold;
		at: #methodTempBar put: blackBold;
		at: #leftParenthesis put: blackBold;
		at: #rightParenthesis put: blackBold;
		at: #leftParenthesis3 put: blackBold;
		at: #rightParenthesis3 put: blackBold;
		at: #leftParenthesis6 put: blackBold;
		at: #rightParenthesis6 put: blackBold;
		at: #blockStart put: blackBold;
		at: #blockEnd put: blackBold;
		at: #blockStart3 put: blackBold;
		at: #blockEnd3 put: blackBold;
		at: #blockStart6 put: blackBold;
		at: #blockEnd6 put: blackBold;
		at: #leftBrace put: blackBold;
		at: #rightBrace put: blackBold;
		at: #leftBrace3 put: blackBold;
		at: #rightBrace3 put: blackBold;
		at: #leftBrace6 put: blackBold;
		at: #rightBrace6 put: blackBold;
		at: #messagePatternDecl put: bold;
		at: #class put: gray;
		at: #transient put: gray;
		at: #className put: bold;
		at: #comment put: blue;
		at: #type put: blueBold;
		at: #return put: blueBold;
		at: #leftParenthesis1 put: blueBold;
		at: #rightParenthesis1 put: blueBold;
		at: #leftParenthesis4 put: blueBold;
		at: #rightParenthesis4 put: blueBold;
		at: #leftParenthesis7 put: blueBold;
		at: #rightParenthesis7 put: blueBold;
		at: #blockStart1 put: blueBold;
		at: #blockEnd1 put: blueBold;
		at: #blockStart4 put: blueBold;
		at: #blockEnd4 put: blueBold;
		at: #blockStart7 put: blueBold;
		at: #blockEnd7 put: blueBold;
		at: #leftBrace1 put: blueBold;
		at: #rightBrace1 put: blueBold;
		at: #leftBrace4 put: blueBold;
		at: #rightBrace4 put: blueBold;
		at: #leftBrace7 put: blueBold;
		at: #rightBrace7 put: blueBold;
		at: #leftParenthesis2 put: magentaBold;
		at: #rightParenthesis2 put: magentaBold;
		at: #leftParenthesis5 put: magentaBold;
		at: #rightParenthesis5 put: magentaBold;
		at: #blockStart2 put: magentaBold;
		at: #blockEnd2 put: magentaBold;
		at: #blockStart5 put: magentaBold;
		at: #blockEnd5 put: magentaBold;
		at: #leftBrace2 put: magentaBold;
		at: #rightBrace2 put: magentaBold;
		at: #leftBrace5 put: magentaBold;
		at: #rightBrace5 put: magentaBold;
		yourself
)
cssFor: k <Symbol> ^ <String> = (
        ^cssConverter at: k ifAbsent: [ 'color:Black; font-family: TimesNewRoman']
)
lexicallyLessOrEqual: a <String> than: b <String> ^ <Boolean> = (
	1 to: (a size min: b size) do:
		[:index |
		 (a at: index) < (b at: index) ifTrue: [^true].
		 (a at: index) > (b at: index) ifTrue: [^false]].
	^a size <= b size
)
summarizeComment: comment <String> ^<String> = (
	| start stop |
	start:: 1.
	stop:: (comment indexOf: '.') - 1.
	[start <= comment size and: [(comment at: start) <= 32]]
		whileTrue: [start:: start + 1].
	stop < start ifTrue: [stop:: comment size].
	^comment copyFrom: start to: stop
)
summarizeCommentFromMetadata: metadata = (
	nil = metadata ifTrue: [^''].
	metadata do: [:ea | ea tag = nil ifTrue: [^summarizeComment: ea payload]].
	^''
)
) : (
)
